## 归并排序

![](https://raw.githubusercontent.com/wangkaiwd/drawing-bed/master/20201213223803.png)
由于在`merge`过程中新创建了一个数组来存储原数组的内容，所以归并排序并不是一个原地排序算法

* sort
* merge: 自己想思路来实现

### 归并

* 将俩个各自排序好的数组合并为一个排序好的数组
* 对每一半进行排序

理解：

* 宏观理解
* 微观理解

测试：

* testHelper：前一个元素永远小于等于后一个元素

### 时间复杂度

* 绘制递归树
* O(nlogn)
* 与n平方的复杂度进行对比

### 优化

* arr[mid] < arr[mid+1] 说明已经排好序了，不用再执行`merge`方法： 对于已经排序好的数组，时间复杂度是O(n)
* 数据量较小时使用插入排序法，此时需要改写插入排序法

### 自底向上归并排序

* 使用插入排序优化自底向上的归并排序

### 总结

* 递归算法
* 分治算法
* 时间复杂度是如何得出的
* 空间复杂度: O(n), 在merge时需要单独拷贝一个数组来存储原始数组，方便查找原始值

### leetcode

* 剑指offer 51. 数组中的逆序对： 在problems中有剑指offer的专题，要在这里进行查找题目
