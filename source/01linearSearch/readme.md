## 线性查找

输入：数组，目标函数  
输出：目标元素所在索引；若不存在，返回-1

* 循环不变量
  * 循环的目标不会变化

### 复杂度分析

* 通常看最差的情况
* n: 数据的规模
* 复杂度描述的是随着数据规模n的增大，算法性能的变化趋势

#### 复杂度例子

空间复杂度同理：O(1) < O(logn) < O(√n) < O(n) < O(nlogn) < O(n²) < O(2n次方) < O(n!)

明确`n`是谁？

判断数字`n`是否是偶数？O(1)

```js
return n % 2 === 0
```

O(n²)：

```js
for (let i = 0; i < arr.length; i++) {
  // i+1, j<i的情况会重复，不进行处理，所以实际上相当于 (½n²)
  for (let j = i + 1; i < arr.length; i++) {
    // data[i],data[j]
  }
}
```

```js
for (let i = 0; i < arr.length; i++) {
  // i+1, j<i的情况会重复，不进行处理，所以实际上相当于 (2/1 n平方)，但是常数不做考虑
  for (let j = 0; i < arr.length; i++) {
    // data[i],data[j]
  }
}
```

数字`n`的二进制位数(对数级别O(㏒n)):

```js
// ㏒2n
while (n) {
  n % 2
  n = n / 2
}
```

数字`n`的所有约数(O√n)：

```js
// O(n)
for (let i = 1; i <= n; i++) {
  if (n % i === 0) {
    // i是n的一个约数
  }
}
// O√n
for (let i = 0; i * i <= n; i++) {
  if (n % i === 0) {
    // i n/i 是n的俩个约数
  }
}
```

* 长度为n的二进制数字O(2n次方)

* 长度为n的所有数组的排列(阶乘O(n!))

### 测试算法性能

* 多次运行的时间,s为单位
